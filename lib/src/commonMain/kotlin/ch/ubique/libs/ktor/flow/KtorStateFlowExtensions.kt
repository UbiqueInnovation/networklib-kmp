package ch.ubique.libs.ktor.flow

import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.awaitCancellation
import kotlinx.coroutines.flow.*

/**
 * Switches to a new [KtorStateFlow] generated by [transform] whenever the source flow emits a new value.
 */
@OptIn(ExperimentalCoroutinesApi::class)
fun <T, R> Flow<T>.flatMapLatestToKtorStateFlow(
	transform: (T) -> KtorStateFlow<R>,
): KtorStateFlow<R> {
	var latestInnerFlow: KtorStateFlow<R>? = null
	val requireLatestInnerFlow = { requireNotNull(latestInnerFlow) }

	val flatMappedFlow = flatMapLatest { value ->
		val innerFlow = transform(value)
		latestInnerFlow = innerFlow
		innerFlow
	}

	val flatMappedFlowWrapper = object : StateFlow<R> {
		override val replayCache: List<R>
			get() = requireLatestInnerFlow().replayCache

		override val value: R
			get() = requireLatestInnerFlow().value

		override suspend fun collect(collector: FlowCollector<R>): Nothing {
			flatMappedFlow.collectLatest {
				collector.emit(it)
			}
			awaitCancellation()
		}
	}

	val flatMappedKtorStateFlowWrapperWrapper = object : KtorStateFlow<R>(flatMappedFlowWrapper) {
		override fun reload() {
			latestInnerFlow?.reload()
		}

		override fun forceReload() {
			latestInnerFlow?.forceReload()
		}
	}

	return flatMappedKtorStateFlowWrapperWrapper
}
