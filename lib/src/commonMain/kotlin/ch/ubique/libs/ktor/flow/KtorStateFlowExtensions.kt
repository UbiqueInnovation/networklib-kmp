package ch.ubique.libs.ktor.flow

import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.awaitCancellation
import kotlinx.coroutines.flow.*

/**
 * Switches to a new [KtorStateFlow] generated by [transform] whenever the source flow emits a new value.
 *
 * ```
 * // myKtorFlow always refers to the latest KtorStateFlow generated by flatMapLatestToKtorStateFlow
 * val myKtorFlow = someInputFlow.flatMapLatestToKtorStateFlow { input ->
 *     // create a new KtorStateFlow for each input value
 *     ktorStateFlow<Int> { cacheControl ->
 *         client.get("http://example.com/?param=$input") {
 *             cacheControl(cacheControl)
 *         }
 *     }
 * }
 * ```
 *
 * Calling `myKtorFlow.reload()` will reload the latest KtorStateFlow.
 *
 * See also [Flow.flatMapLatest].
 *
 * @param transform A function that takes a value emitted by the source flow and returns a new [KtorStateFlow].
 */
@OptIn(ExperimentalCoroutinesApi::class)
fun <T, R : RequestState<*>> Flow<T>.flatMapLatestToKtorStateFlow(
	transform: (T) -> KtorStateFlow<R>,
): KtorStateFlow<R> {
	var latestInnerFlow: KtorStateFlow<R>? = null

	val flatMappedFlow = flatMapLatest { value ->
		val innerFlow = transform(value)
		latestInnerFlow = innerFlow
		innerFlow
	}

	val flatMappedFlowWrapper = object : StateFlow<R> {
		override val replayCache: List<R>
			get() = latestInnerFlow?.replayCache.orEmpty()

		@Suppress("UNCHECKED_CAST")
		override val value: R
			get() = latestInnerFlow?.value ?: RequestState.Loading as R

		override suspend fun collect(collector: FlowCollector<R>): Nothing {
			flatMappedFlow.collectLatest {
				collector.emit(it)
			}
			awaitCancellation()
		}
	}

	val flatMappedKtorStateFlowWrapperWrapper = object : KtorStateFlow<R>(flatMappedFlowWrapper) {
		override fun reload() {
			latestInnerFlow?.reload()
		}

		override fun forceReload() {
			latestInnerFlow?.forceReload()
		}
	}

	return flatMappedKtorStateFlowWrapperWrapper
}
